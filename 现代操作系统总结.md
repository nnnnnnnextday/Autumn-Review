## 重点一：用户态和内核态

特权级是指令集架构下的一部分，

而用户态与内核态又是组成特权级的一部分。

（指令集架构，即Instruction Set Architecture,即ISA,是CPU和软件之间的桥梁，包含指令集，特权级，寄存器，执行模式等多方面）

特权级：以AArch64体系结构的特权级为例

![image-20210602215501450](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/1.png)

应用程序通常运行在用户态，而操作系统通常运行在内核态。二者合作完成程序运行。



而从应用程序切换到操作系统，一般场景有三种。

1. 应用程序需要调用操作系统提供的系统调用，此时应用程序会执行指令将CPU的特权级从用户态转换到内核态。

2. 在应用程序执行指令期间，触发了某个异常，该异常导致CPU特权级从用户态转换到内核态。例如，某应用程序在执行一条访存指令时，触发了缺页异常，从而转换到内核态进行异常处理。

   --------

   前两种场景都属于同步情况。

3. 应用程序执行过程中，CPU收到一个中断，从而导致其转换到内核态。例如，进程的上下文切换过程。

![image-20210602214937421](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/2.png)

## 重点二：内存管理

### 虚拟地址和物理地址

虚拟内存的必要性：

1. 无法保证不同应用程序所使用的物理内存之间的隔离性。
2. 无法保证应用程序可用的地址空间是连续，统一的，增加了复杂性。

当引入虚拟内存后，应用程序运行时只使用虚拟地址，而**CPU负责将虚拟地址翻译成物理地址，操作系统负责设置虚拟地址和物理地址之间的映射**。

![image-20210602220045064](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/3.png)

MMU：即内存管理单元（Memory Management Unit），负责虚拟地址到物理地址的转换。

TLB：即转址旁路缓存（Translation Lookaside Buffer）,属于MMU内部的单元

**我个人认为MMU和TLB之间的关系有点类似于MySQL和Redis**



## 重点三：分段与分页机制

MMU将虚拟地址翻译成物理地址的主要机制有两种：分段机制和分页机制

### 分段机制

在该机制下，操作系统以“段”（即一段连续的物理内存）的形式管理物理内存。应用程序的虚拟地址空间由若干个**不同大小**的段组成。

当CPU访问虚拟地址空间中的某一个段时，MMU会通过查询**段表**得到该段对于的物理内存区域。



具体来说，虚拟地址由两部分组成，即**段号**和**段内地址（或叫做段内偏移）**

段号标识着该虚拟地址属于虚拟地址空间中的哪一个段，而段内偏移是相对于该段起始地址的偏移量。



MMU翻译虚拟地址的具体过程如下：

MMU首先通过寄存器中信息，找到段表位置，再结合段号，即可得到对应段的信息；

然后取出该段的起始地址（**物理地址**），加上段内偏移量，即可得到最终的物理地址。

![image-20210602221743578](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/4.png)

弊端：在分段机制下，物理内存也是分段管理的。而且虚拟地址中相邻段对应的物理内存的段可以不相邻，这就导致了内存资源的离散分配。容易产生内存碎片问题。



### 分页机制

其基本思想是将应用程序的虚拟地址空间划分成连续，**等长**的虚拟页，物理页同理。

其与分段机制的最大区别即划分空间的大小是否一致。

对应于分段机制的段号和段内偏移，分页机制有**页号**和**页内偏移量**

而操作系统也能够很方便地为每个应用程序构造**页表**，即虚拟地址映射到物理地址的关系表。

MMU翻译虚拟地址的具体过程如下：

MMU首先解析得到虚拟地址中的虚拟页号，并通过虚拟页号去该应用程序对应的页表（还是需要借助特定寄存器）里找到对应数据；

然后取出其中的物理页号，最后用物理页号对应的物理地址加上页内偏移量得到最终的物理地址。

![image-20210602222910400](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/5.png)



## 重点四：进程和线程

### 进程的内存空间布局

![image-20210604162536235](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/6.png)

### 线程的内存空间布局

![image-20210604162551866](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/7.png)

## 重点五：进程间通信

### 进程间通信的实现基础：

我们大部分情况下谈到的进程间通信都是Linux OS下的（Linux OS内核 本身属于宏内核范畴，微内核范畴的进程间通信有另外一套机制）

进程间通信的实现基础包括：

1. 通信模型
2. 数据传递
3. 控制流转移
4. 单双向概念
5. 同步异步概念
6. 超时机制
7. 通信连接管理
8. 权限检查
9. 命名服务

实现的基础内容太多了，只能加深理解，不是进程通信本身的重点...有兴趣的话可以私聊我，我拍一下。

### 进程通信：

1. 管道进程间通信

   ​		一个简单的例子是：ps aux | grep target，用于查看当前是否有关键字target相关的进程在运行。这里其实是两个命令，|是管道符号，将前半部分的命令输出到一个管道中，而管道对应的出口是第二个命令的输入。通过管道，ps和grep这两个命令完成了合作。

   ​		具体实现上，管道会被当做一个文件，内核会为用户态提供代表管道的文件描述符，让其能够调用。管道的特殊在于，它的创建会返回两个文件描述符（参考上一段的例子，读和写，所以两个），而且管道并不会使用硬盘，而是仅仅使用内存，保证了高性能。

   ​		管道主要有两种，即匿名管道和命名管道，其不仅在用途上有区别，创建方式也有所区别。

   ​		匿名管道是通过pipe的系统调用来创建的，而创建后会伴随两个文件描述符，但匿名管道没有自身的“名字”，所以也只能通过这两个文件描述符来使用它。通常的使用情况是需要结合fork的，即用继承的方式来实现父子进程之间的通信，具体过程：父进程首先通过pipe创建好管道的读写两端，然后fork出子进程，由于子进程可以继承文件描述符，所以二者就可以完成进程间通信了。

   ​		而命名管道是通过mkfifo命令来创建的，并且创建时需要给管道一个全局路径描述的名字，例如/tmp/namepipe,通过这种方式，就可实现在任意两个进程间通过管道来通信。

   ![image-20210604170156563](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/8.png)

2. 消息队列

   ​	消息队列的特殊在于，它是极少使用“消息”这一数据类型来进行通信的（消息是内核进行提供的，所以在用户态和内核态之间传递时，较之其他方式有开销）。消息队列支持同时存在多个发送者/接受者，并且在消息队列中为每个消息的数据类型进行了分类，方便发送者和接受者进行选择性的消息处理。

   ![image-20210604170204166](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/9.png)

3. 信号量

   ​	和其他进程间通信专注于“信息传递”不同，信号量主要是作用于进程间的同步。信号量的操作主要是两个原语：P（Probeer，尝试，在信号量中通常是将一个计数器-1）和V（Verhoog，增加，在信号量中通常是将一个计数器+1）。PV操作都是在信号量结构上进行的，该结构会封装一个计数器。所以，一个P操作的失败，可能会让当前进程切换到阻塞状态；一个V操作也可能唤醒一个陷入阻塞的进程。

4. 共享内存

   ​	共享内存的思路是内核为需要通信的进程建立共享区域。一旦共享区域完成建立，内核基本上就不需要参与进程间的通信。其实现的核心思想也很简单，即共享内存允许一个或多个进程在其所在的虚拟地址中映射相同的物理内存页，从而进行通信。

   ![image-20210604172033623](https://github.com/nnnnnnnextday/Autumn-Review/tree/master/pics/10.png)

5. 信号

   ​	是一种特殊的通信机制，一个简单的例子就是Ctrl+C来终止一个执行中的程序。背后的逻辑即Shell发出了一个SIGINT信号。

6. 套接字

   ​	是一种既可用于本地，又可跨网络使用的通信机制。

